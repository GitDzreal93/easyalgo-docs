---
title: 121. 买卖股票的最佳时机
description: 在只允许一次买卖的情况下，找到股票的最大利润。
date: 2024-03-15
tag: ["简单", "数组", "动态规划"]
author: Easy Algo-臻叔
premium: false
percentage: 53
---

## 题目

> leetcode 链接： [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1**：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2**：
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示**：
```
1 <= prices.length <= 105
0 <= prices[i] <= 104
```

## 题解

**题意简化：**

想象你有一张纸，上面记着一支玩具股票每天的价格。你只能买一次，卖一次，而且卖的时候必须是你买的那天 *以后* 的某一天。你想找到一个最好的买入日期和一个最好的卖出日期，让卖出价格减去买入价格的差最大。这个最大的差就是你的最大利润。如果股票价格一直跌，你没法赚钱（卖出日的价格总是小于等于买入日的价格），那么你的最大利润就是 0。

**边界值与测试用例：**

*   **边界值：**
    *   数组长度最小为 1。
    *   数组长度为 2（只有买入和卖出两个日期）。
    *   股票价格一直上涨。
    *   股票价格一直下跌。
    *   股票价格有涨有跌。
    *   价格可能为 0。
    *   价格可能达到提示中的最大值 10^4。

*   **测试用例：**

    | 输入 (prices)          | 预期输出 | 说明                             |
    | :--------------------- | :------- | :------------------------------- |
    | `[7, 1, 5, 3, 6, 4]`   | `5`      | 标准示例，有利润                 |
    | `[7, 6, 4, 3, 1]`      | `0`      | 标准示例，价格持续下跌           |
    | `[1]`                  | `0`      | 数组长度为 1，无法交易           |
    | `[1, 5]`               | `4`      | 数组长度为 2，价格上涨           |
    | `[5, 1]`               | `0`      | 数组长度为 2，价格下跌           |
    | `[2, 4, 1]`            | `2`      | 价格先涨后跌 (买 2 卖 4)         |
    | `[3, 3, 5, 0, 0, 3, 1, 4]` | `4`      | 更复杂的价格波动 (买 0 卖 4)     |
    | `[0, 10000]`           | `10000`  | 价格跨度大，最大利润             |

**解法分析：**

| 解法             | 优点             | 缺点                         | 时间复杂度       | 空间复杂度 |
| :--------------- | :--------------- | :--------------------------- | :--------------- | :--------- |
| 暴力搜索         | 简单直观         | 效率最低，超时               | O(n^2)           | O(1)       |
| 一次遍历（最小价格） | 高效，满足要求   | 需要理解“记录之前最低价格”的思路 | O(n)             | O(1)       |
| 动态规划（类似）   | 结构清晰         | 与一次遍历本质相同，可能稍显复杂 | O(n)             | O(1)       |

*   **复杂度评估方法：**
    *   时间复杂度：衡量算法执行所需计算操作数量随输入规模 (n，数组长度) 增长的速度。O(n^2) 随 n 的平方增长，非常慢；O(n) 随 n 线性增长，效率较高。
    *   空间复杂度：衡量算法运行时占用的额外内存空间随输入规模 (n) 增长的速度。O(1) 表示额外空间是常数，不随 n 变化。

*   **推荐解法：**

    一次遍历（记录之前最小价格）。这个方法非常巧妙且高效。我们只需要从头到尾遍历一遍价格数组。在遍历的每一天，我们做两件事：
    1.  计算如果今天卖出股票，能获得的最大利润是多少（用今天的价格减去到目前为止见过的最低买入价格）。
    2.  更新到目前为止见过的最低买入价格（如果今天的价格比之前的最低价还要低，就更新最低价）。
    通过这种方式，我们可以在一次遍历中找到最大的利润差，时间复杂度为 O(n)，并且只需要额外几个变量来存储最低价格和最大利润，空间复杂度为 O(1)。这是解决这个问题的标准且最优解法，非常适合面试。

**Python 代码实现：**

*   **版本一：包含详细注释**

```python
import math # 导入 math 模块以便使用无穷大 float('inf')

def maxProfit(prices):
    """
    计算在给定股票价格数组中一次买卖能获得的最大利润。

    Args:
        prices: 列表，表示每天的股票价格。

    Returns:
        最大利润，如果无法获得利润则返回 0。
    """
    # 如果数组长度小于等于 1，无法进行买卖，利润为 0
    # 实际上即使长度为 1，循环逻辑也能返回 0，但这个显式检查更清晰。
    # 题目提示 1 <= prices.length，所以长度为 0 的情况不会出现。
    # 但长度为 1 确实无法进行买卖。
    if len(prices) <= 1:
        return 0

    # 初始化最低买入价格为一个很大的值，保证第一个价格一定比它小
    min_price = float('inf')
    # 初始化最大利润为 0，因为最差情况就是不交易，利润为 0
    max_profit = 0

    # 遍历每天的股票价格
    for price in prices:
        # 1. 计算如果今天卖出，潜在的最大利润是多少？
        # 这是今天的价格减去到目前为止见过的最低价格。
        # 这一步是假设我们在 min_price 那天买入，在 price 这天卖出。
        potential_profit = price - min_price

        # 2. 更新我们找到的全局最大利润。
        # 如果当前的潜在利润比之前记录的最大利润还要大，就更新最大利润。
        max_profit = max(max_profit, potential_profit)

        # 3. 更新到目前为止见过的最低买入价格。
        # 如果今天的价格比之前记录的最低价格还要低，就更新最低价格。
        # 这个新的最低价格将用于计算未来日期的潜在利润。
        min_price = min(min_price, price)

    # 遍历结束后，max_profit 存储的就是我们能获得的最大利润
    # 如果整个过程中 potential_profit 都小于等于 0，max_profit 会一直保持初始值 0
    return max_profit

# ## 测试用例 (用于验证代码，实际提交时一般不包含)
# print(f"Input: [7, 1, 5, 3, 6, 4]\nOutput: {maxProfit([7, 1, 5, 3, 6, 4])}") # 预期: 5
# print(f"Input: [7, 6, 4, 3, 1]\nOutput: {maxProfit([7, 6, 4, 3, 1])}")     # 预期: 0
# print(f"Input: [1]\nOutput: {maxProfit([1])}")                           # 预期: 0
# print(f"Input: [1, 5]\nOutput: {maxProfit([1, 5])}")                       # 预期: 4
# print(f"Input: [5, 1]\nOutput: {maxProfit([5, 1])}")                       # 预期: 0
# print(f"Input: [2, 4, 1]\nOutput: {maxProfit([2, 4, 1])}")                   # 预期: 2
# print(f"Input: [3, 3, 5, 0, 0, 3, 1, 4]\nOutput: {maxProfit([3, 3, 5, 0, 0, 3, 1, 4])}") # 预期: 4
```

*   **版本二：去除所有注释**

```python
import math

def maxProfit(prices):
    if len(prices) <= 1:
        return 0

    min_price = float('inf')
    max_profit = 0

    for price in prices:
        potential_profit = price - min_price
        max_profit = max(max_profit, potential_profit)
        min_price = min(min_price, price)

    return max_profit
```

**代码运行过程详细描述：**

以输入 `prices = [7, 1, 5, 3, 6, 4]` 为例：

1.  检查数组长度，大于 1，继续。
2.  初始化 `min_price = float('inf')` (一个非常大的数), `max_profit = 0`.
3.  开始遍历 `prices` 数组：
    *   处理价格 `7`:
        *   `potential_profit = 7 - float('inf')` (非常小的负数).
        *   `max_profit = max(0, 非常小的负数) = 0`. `max_profit` 保持 0。
        *   `min_price = min(float('inf'), 7) = 7`. `min_price` 更新为 7。
    *   处理价格 `1`:
        *   `potential_profit = 1 - min_price = 1 - 7 = -6`.
        *   `max_profit = max(0, -6) = 0`. `max_profit` 保持 0。
        *   `min_price = min(7, 1) = 1`. `min_price` 更新为 1。
    *   处理价格 `5`:
        *   `potential_profit = 5 - min_price = 5 - 1 = 4`.
        *   `max_profit = max(0, 4) = 4`. `max_profit` 更新为 4。
        *   `min_price = min(1, 5) = 1`. `min_price` 保持 1。
    *   处理价格 `3`:
        *   `potential_profit = 3 - min_price = 3 - 1 = 2`.
        *   `max_profit = max(4, 2) = 4`. `max_profit` 保持 4。
        *   `min_price = min(1, 3) = 1`. `min_price` 保持 1。
    *   处理价格 `6`:
        *   `potential_profit = 6 - min_price = 6 - 1 = 5`.
        *   `max_profit = max(4, 5) = 5`. `max_profit` 更新为 5。
        *   `min_price = min(1, 6) = 1`. `min_price` 保持 1。
    *   处理价格 `4`:
        *   `potential_profit = 4 - min_price = 4 - 1 = 3`.
        *   `max_profit = max(5, 3) = 5`. `max_profit` 保持 5。
        *   `min_price = min(1, 4) = 1`. `min_price` 保持 1。
4.  遍历结束。
5.  返回 `max_profit` 的值 5。

这个过程确保了在计算每一天的潜在利润时，都是用当天价格减去之前遇到的最低价格，从而找到在当天卖出可能获得的最高利润。通过不断更新 `max_profit`，最终就能得到整个时间段内的最大利润。