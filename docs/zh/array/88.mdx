---
title: 88. 合并两个有序数组
description: 在nums1的末尾空间中合并两个非递减排序的数组nums1和nums2，使其保持有序。
date: 2024-03-15
tag: ["简单", "数组", "双指针"]
author: Easy Algo-臻叔
premium: false
percentage: 58
---

## 题目

> leetcode 链接： [合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

给你两个按 非递减顺序 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 合并 `nums2` 到 `nums1` 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例 1**：

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2**：
```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```


**示例 3**：
```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

**提示**：
```
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
nums1 和 nums2 均按 非递减顺序 排列
```

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

## 题解

**题意简化：**

想象你有两叠已经从小到大排好的扑克牌，一叠是 `nums1` 的前 `m` 张（后面跟着 `n` 张空白牌或者别的什么），另一叠是 `nums2` 的 `n` 张。你的任务是把 `nums2` 里的牌，都按照从小到大的顺序，插进 `nums1` 前面那 `m` 张牌的合适位置里。最终，`nums1` 的前 `m+n` 个位置要变成这两叠牌合并后从小到大排列的样子。你必须直接在 `nums1` 这叠牌上操作，不能再拿出新的牌来重新排。

**边界值与测试用例：**

*   **边界值：**
    *   `m = 0`：`nums1` 刚开始没有有效元素，需要把 `nums2` 全部复制过去。
    *   `n = 0`：`nums2` 是空的，不需要合并，`nums1` 已经是最终结果。
    *   `m > 0, n > 0`：一般情况，两个非空数组合并。
    *   `nums1` 中的所有元素都小于 `nums2` 中的所有元素。
    *   `nums2` 中的所有元素都小于 `nums1` 中的所有元素。
    *   数组包含负数、零、正数，且数值范围较大。

*   **测试用例：**

    | 输入 (nums1, m, nums2, n)      | 输出 (修改后的 nums1) | 说明                             |
    | :------------------------------- | :-------------------- | :------------------------------- |
    | `([1,2,3,0,0,0], 3, [2,5,6], 3)` | `[1,2,2,3,5,6]`       | 标准示例，交错合并               |
    | `([1], 1, [], 0)`                | `[1]`                 | `n = 0` 边界                     |
    | `([0], 0, [1], 1)`               | `[1]`                 | `m = 0` 边界                     |
    | `([-5, 0, 0, 0], 1, [-3, 2], 2)` | `[-5, -3, 0, 2]`      | 包含负数，交错合并               |
    | `([1, 2, 0, 0], 2, [3, 4], 2)`   | `[1, 2, 3, 4]`        | `nums1` 全小于 `nums2`           |
    | `([3, 4, 0, 0], 2, [1, 2], 2)`   | `[1, 2, 3, 4]`        | `nums2` 全小于 `nums1`           |
    | `([1, 1, 2, 0, 0], 3, [1, 2], 2)` | `[1, 1, 1, 2, 2]`     | 包含重复元素                     |

**解法分析：**

| 解法             | 优点             | 缺点                                   | 时间复杂度 | 空间复杂度 |
| :--------------- | :--------------- | :------------------------------------- | :--------- | :--------- |
| 复制后排序       | 简单易懂         | 未利用数组的有序性，效率较低           | O((m+n)log(m+n)) | O(1) 或 O(m+n) |
| 双指针（从前往后） | 利用有序性，思路直观 | 需要额外 O(m+n) 空间存放合并结果       | O(m+n)     | O(m+n)     |
| 双指针（从后往前） | 高效，满足原地和 O(1) 空间要求 | 指针逻辑稍复杂，特别是处理剩余元素     | O(m+n)     | O(1)       |

*   **复杂度评估方法：**
    *   时间复杂度：评估算法完成所需计算操作随输入规模 (m+n) 增长的速度。O((m+n)log(m+n)) 增长较快，O(m+n) 增长较慢（与 m+n 成正比）。
    *   空间复杂度：评估算法额外占用的内存空间随输入规模 (m+n) 增长的速度。O(m+n) 表示额外空间与 m+n 成正比，O(1) 表示额外空间是常数，不随 m+n 变化。

*   **推荐解法：**

    双指针（从后往前）。这是最符合题目要求（原地合并，O(1) 额外空间）且达到最优时间复杂度 O(m+n) 的解法。利用 `nums1` 末尾的额外空间，从后往前放置较大的元素，避免了覆盖掉 `nums1` 前面尚未比较的有效元素。虽然理解指针移动需要一点思考，但掌握后是解决这类合并问题的标准方法，非常适合面试。

**Python 代码实现：**

*   **版本一：包含详细注释**

```python
def merge(nums1, m, nums2, n):
    """
    合并两个非递减排序的数组 nums2 到 nums1 中，使 nums1 保持有序。

    Args:
        nums1: 第一个数组，长度为 m+n，前 m 个元素为有效数据，后 n 个元素为 0。
        m: nums1 中的有效元素个数。
        nums2: 第二个数组，长度为 n。
        n: nums2 中的元素个数。

    Returns:
        None. 直接修改 nums1 数组。
    """
    # 初始化三个指针
    # p1 指向 nums1 中有效部分的最后一个元素 (下标 m-1)
    p1 = m - 1
    # p2 指向 nums2 的最后一个元素 (下标 n-1)
    p2 = n - 1
    # p 指向 nums1 中合并后元素的放置位置，从 nums1 的最后一个位置开始 (下标 m+n-1)
    p = m + n - 1

    # 从后往前比较并放置元素，直到 nums2 中的所有元素都处理完毕 (p2 < 0)
    # 或者 nums1 中的有效部分所有元素都处理完毕 (p1 < 0)
    while p1 >= 0 and p2 >= 0:
        # 比较 nums1 当前有效部分的末尾元素和 nums2 当前末尾元素
        if nums1[p1] >= nums2[p2]:
            # 如果 nums1 的元素较大或相等，将其放到 nums1 的当前放置位置 p
            nums1[p] = nums1[p1]
            # 将 nums1 的指针向前移动一位
            p1 -= 1
        else:
            # 如果 nums2 的元素较大，将其放到 nums1 的当前放置位置 p
            nums1[p] = nums2[p2]
            # 将 nums2 的指针向前移动一位
            p2 -= 1
        # 无论从哪个数组取了元素，放置位置 p 都向前移动一位
        p -= 1

    # 如果循环结束后 nums2 中还有剩余元素 (即 p2 >= 0)
    # 说明 nums2 中剩余的元素都比 nums1 中剩余的有效元素（如果有的话）小
    # 需要将 nums2 中剩余的元素直接复制到 nums1 的前面剩余位置
    # 注意：如果 nums1 中还有剩余元素 (p1 >= 0)，它们本身已经在 nums1 的前面并且是有序的，
    # 所以不需要额外处理。
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1

    # 函数不需要返回，因为已经直接修改了 nums1 数组

# ## 测试用例 (用于验证代码，实际提交时一般不包含)
# nums1_1 = [1,2,3,0,0,0]
# merge(nums1_1, 3, [2,5,6], 3)
# print(f"Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: {nums1_1}") # 预期: [1, 2, 2, 3, 5, 6]
#
# nums1_2 = [1]
# merge(nums1_2, 1, [], 0)
# print(f"Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: {nums1_2}") # 预期: [1]
#
# nums1_3 = [0]
# merge(nums1_3, 0, [1], 1)
# print(f"Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: {nums1_3}") # 预期: [1]
#
# nums1_4 = [-5, 0, 0, 0]
# merge(nums1_4, 1, [-3, 2], 2)
# print(f"Input: nums1 = [-5, 0, 0, 0], m = 1, nums2 = [-3, 2], n = 2\nOutput: {nums1_4}") # 预期: [-5, -3, 0, 2]
#
# nums1_5 = [1, 2, 0, 0]
# merge(nums1_5, 2, [3, 4], 2)
# print(f"Input: nums1 = [1, 2, 0, 0], m = 2, nums2 = [3, 4], n = 2\nOutput: {nums1_5}") # 预期: [1, 2, 3, 4]
#
# nums1_6 = [3, 4, 0, 0]
# merge(nums1_6, 2, [1, 2], 2)
# print(f"Input: nums1 = [3, 4, 0, 0], m = 2, nums2 = [1, 2], n = 2\nOutput: {nums1_6}") # 预期: [1, 2, 3, 4]
```

*   **版本二：去除所有注释**

```python
def merge(nums1, m, nums2, n):
    p1 = m - 1
    p2 = n - 1
    p = m + n - 1

    while p1 >= 0 and p2 >= 0:
        if nums1[p1] >= nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1

    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```

**代码运行过程详细描述：**

以输入 `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3` 为例：

1.  初始化指针：
    *   `p1` 指向 `nums1` 的有效末尾：`m - 1 = 3 - 1 = 2`. `nums1[2]` 是 3。
    *   `p2` 指向 `nums2` 的末尾：`n - 1 = 3 - 1 = 2`. `nums2[2]` 是 6。
    *   `p` 指向 `nums1` 的总末尾：`m + n - 1 = 3 + 3 - 1 = 5`. `nums1[5]` 是 0。
    `nums1` = `[1, 2, 3, 0, 0, 0]`
    `nums2` = `[2, 5, 6]`

2.  进入主 `while p1 >= 0 and p2 >= 0` 循环：
    *   当前 `p1 = 2`, `p2 = 2`. `nums1[2]` (3) vs `nums2[2]` (6)。 6 较大。
        *   将 `nums2[2]` (6) 放到 `nums1[p]` (`nums1[5]`)。`nums1` 变为 `[1, 2, 3, 0, 0, **6**]`.
        *   `p2` 向前移： `p2 = 1`.
        *   `p` 向前移： `p = 4`.
    *   当前 `p1 = 2`, `p2 = 1`. `nums1[2]` (3) vs `nums2[1]` (5)。 5 较大。
        *   将 `nums2[1]` (5) 放到 `nums1[p]` (`nums1[4]`)。`nums1` 变为 `[1, 2, 3, 0, **5**, 6]`.
        *   `p2` 向前移： `p2 = 0`.
        *   `p` 向前移： `p = 3`.
    *   当前 `p1 = 2`, `p2 = 0`. `nums1[2]` (3) vs `nums2[0]` (2)。 3 较大。
        *   将 `nums1[2]` (3) 放到 `nums1[p]` (`nums1[3]`)。`nums1` 变为 `[1, 2, 3, **3**, 5, 6]`.
        *   `p1` 向前移： `p1 = 1`.
        *   `p` 向前移： `p = 2`.
    *   当前 `p1 = 1`, `p2 = 0`. `nums1[1]` (2) vs `nums2[0]` (2)。 2 >= 2。`nums1[1]` (2) 较大或相等，选择 `nums1` 的元素。
        *   将 `nums1[1]` (2) 放到 `nums1[p]` (`nums1[2]`)。`nums1` 变为 `[1, 2, **2**, 3, 5, 6]`.
        *   `p1` 向前移： `p1 = 0`.
        *   `p` 向前移： `p = 1`.
    *   当前 `p1 = 0`, `p2 = 0`. `nums1[0]` (1) vs `nums2[0]` (2)。 2 较大。
        *   将 `nums2[0]` (2) 放到 `nums1[p]` (`nums1[1]`)。`nums1` 变为 `[1, **2**, 2, 3, 5, 6]`. (注意：这里把 nums2[0] 的 2 覆盖了 nums1 原本的 2，这没关系，因为 nums1[0] 的 1 还没有被移动)。
        *   `p2` 向前移： `p2 = -1`.
        *   `p` 向前移： `p = 0`.

3.  主 `while` 循环终止，因为 `p2` 变成了 -1。

4.  检查 `while p2 >= 0` 循环： `p2` 当前是 -1，循环条件不满足，跳过。

5.  检查 `while p1 >= 0` （这是隐含的，因为 `nums1` 中剩余的有效元素如果在 `p1` 仍 `>=0` 时主循环结束，说明它们比 `nums2` 所有元素都小，本身就应该在数组的最前面，不需要额外移动）。`p1` 当前是 0。`nums1[0]` 是 1。主循环结束时，`p` 是 0。最后一个元素 `nums1[0]` (1) 已经被放在正确的位置，或者如果 `p1` 最后还大于等于0，说明 `nums1` 前面的元素还没被动过，而它们本身就是最小且有序的，也就在正确位置。在此例中，最后一步将 nums2[0] (2) 放在了 nums1[1]，而 nums1[0] 的 1 还在。当 p1 变成 -1 之后，nums1 的前 m 个元素（从索引 0 到 m-1）已经全部被比较和移动完了。

6.  函数结束。`nums1` 最终变为 `[1, 2, 2, 3, 5, 6]`。

这个从后往前的思路巧妙地利用了 `nums1` 后面的空位，避免了在合并过程中覆盖掉前面尚未处理的有效数据。