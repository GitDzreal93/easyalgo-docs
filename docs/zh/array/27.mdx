---
title: 27. 移除元素
description: 在数组中原地移除所有等于特定值的元素，并返回剩余元素的数量。
date: 2024-03-15
tag: ["简单", "数组", "双指针"]
author: Easy Algo-臻叔
premium: false
percentage: 51
---

## 题目

> leetcode 链接： [移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
返回 `k`。

用户评测：

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的期望答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```
如果所有的断言都通过，你的解决方案将会 通过。

**示例 1**：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2**：
```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**提示**：
```
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

## 题解

**题意简化：**

想象你有一排积木，其中有一些积木是红色的（这个红色就是 `val`）。你需要把所有的红色积木都挪到这排积木的最后面去。然后告诉我，前面剩下多少个不是红色（不等于 `val`）的积木。你只能在这排积木里挪动，不能拿出新的积木。而且，前面剩下的不是红色积木，它们的顺序变了也没关系。

**边界值与测试用例：**

*   **边界值：**
    *   数组是空的 (`nums.length == 0`)。
    *   数组中所有元素都等于 `val`。
    *   数组中没有元素等于 `val`。
    *   `val` 等于数组中的最大或最小值。
    *   数组只有一个元素，且等于或不等于 `val`。

*   **测试用例：**

    | 输入 (nums, val)              | 预期输出 (k) | 数组前 k 位 (nums) (任意顺序) | 说明                             |
    | :---------------------------- | :----------- | :---------------------------- | :------------------------------- |
    | `([3, 2, 2, 3], 3)`           | `2`          | `[2, 2]`                      | 标准示例                         |
    | `([0, 1, 2, 2, 3, 0, 4, 2], 2)` | `5`          | `[0, 1, 4, 0, 3]` (或任意排序) | 标准示例，多个重复，顺序可变     |
    | `([], 5)`                     | `0`          | `[]`                          | 空数组                           |
    | `([3, 3, 3], 3)`              | `0`          | `[]`                          | 所有元素等于 val                 |
    | `([1, 2, 4], 3)`              | `3`          | `[1, 2, 4]`                   | 没有元素等于 val                 |
    | `([5], 5)`                    | `0`          | `[]`                          | 单元素等于 val                   |
    | `([5], 6)`                    | `1`          | `[5]`                         | 单元素不等于 val                 |

**解法分析：**

| 解法             | 优点                     | 缺点                                   | 时间复杂度 | 空间复杂度 |
| :--------------- | :----------------------- | :------------------------------------- | :--------- | :--------- |
| 暴力删除（Python `list.remove`） | 语法简单                 | 每次删除 O(N) 移动，总 O(N^2)；改变迭代对象 | O(N^2)     | O(1)       |
| 双指针（快慢指针/写指针） | O(N) 时间，O(1) 空间；保留非 val 元素的相对顺序 | 需要额外的写操作，即使元素本身就在前面 | O(N)       | O(1)       |
| 双指针（交换尾部） | O(N) 时间，O(1) 空间；利用“顺序不重要”的特性 | 指针逻辑稍复杂，尤其处理边界；不保留非 val 相对顺序 | O(N)       | O(1)       |

*   **复杂度评估方法：**
    *   时间复杂度：衡量算法完成所需计算操作随输入规模 (N，数组长度) 增长的速度。O(N^2) 是平方增长，效率最低；O(N) 是线性增长，效率较高。
    *   空间复杂度：衡量算法运行时额外占用的内存空间（不包括输入本身）随输入规模 (N) 增长的速度。O(1) 表示额外空间是个常数，不随 N 变化。

*   **推荐解法：**

    双指针（交换尾部）。尽管双指针（快慢指针）也很常见，但考虑到这道题明确说明“元素的顺序可能发生改变”，并且评测时会对前 k 个元素进行排序，这意味着我们不需要保留非 `val` 元素的原始相对顺序。此时，“交换尾部”的双指针方法能更直接地将等于 `val` 的元素移到数组末尾，而非 `val` 的元素留在或换到数组的前面。这种方法在要移除的元素较多时，可以减少一些不必要的元素移动或复制操作，更契合“移除”的直观感觉，并且是 O(N) 时间和 O(1) 空间的，非常适合面试。

**Python 代码实现：**

*   **版本一：包含详细注释**

```python
def remove_element(nums, val):
    """
    原地移除数组中所有等于 val 的元素，返回剩余元素的数量。

    Args:
        nums: 整数数组。
        val: 需要移除的数值。

    Returns:
        移除后数组中不等于 val 的元素数量 k。
    """
    # 初始化左右指针
    # left 指针从数组开头开始
    left = 0
    # right 指针从数组末尾开始
    right = len(nums) - 1

    # 当 left 指针还没有越过 right 指针时，继续循环
    # left <= right 是为了处理只有一个元素的情况 [val] 或 [other]
    while left <= right:
        # 如果 left 指针指向的元素就是要移除的 val
        if nums[left] == val:
            # 将 right 指针指向的元素复制到 left 指针的位置
            # 这样就把一个非 val (或者即使是 val 也无所谓，反正 right 后面要被忽略)
            # 元素移动到了前面需要保留的位置
            nums[left] = nums[right]
            # 然后将 right 指针向前移动一位，相当于把末尾的元素“移除”了
            right -= 1
            # 注意：此时 left 指针不移动，因为新的 nums[left] 需要重新检查
        else:
            # 如果 left 指针指向的元素不是 val，说明它是需要保留的元素
            # 它已经在正确的位置（数组的前部）
            # 将 left 指针向后移动一位，检查下一个元素
            left += 1

    # 循环结束时，left 指针的最终位置就是不等于 val 的元素的数量
    # 因为 left 从 0 开始计数，所以 left 的值直接代表了前 left 个元素是不等于 val 的
    # 比如，如果 left 最终停在 2，表示 nums[0] 和 nums[1] 是保留的元素，共 2 个。
    # 此时 nums 数组的前 left 个位置就是所有不等于 val 的元素。
    return left

# ## 测试用例 (用于验证代码，实际提交时一般不包含)
# nums1 = [3, 2, 2, 3]
# k1 = remove_element(nums1, 3)
# print(f"Input: nums = [3, 2, 2, 3], val = 3\nOutput k: {k1}, nums[:k]: {nums1[:k1]}") # 预期: k=2, nums[:k] 包含 [2, 2]
#
# nums2 = [0, 1, 2, 2, 3, 0, 4, 2]
# k2 = remove_element(nums2, 2)
# print(f"Input: nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2\nOutput k: {k2}, nums[:k]: {sorted(nums2[:k2])}") # 预期: k=5, nums[:k] 包含 [0, 0, 1, 3, 4] 排序后
#
# nums3 = []
# k3 = remove_element(nums3, 5)
# print(f"Input: nums = [], val = 5\nOutput k: {k3}, nums[:k]: {nums3[:k3]}") # 预期: k=0, nums[:k] 包含 []
#
# nums4 = [3, 3, 3]
# k4 = remove_element(nums4, 3)
# print(f"Input: nums = [3, 3, 3], val = 3\nOutput k: {k4}, nums[:k]: {nums4[:k4]}") # 预期: k=0, nums[:k] 包含 []
#
# nums5 = [1, 2, 4]
# k5 = remove_element(nums5, 3)
# print(f"Input: nums = [1, 2, 4], val = 3\nOutput k: {k5}, nums[:k]: {nums5[:k5]}") # 预期: k=3, nums[:k] 包含 [1, 2, 4]
```

*   **版本二：去除所有注释**

```python
def remove_element(nums, val):
    left = 0
    right = len(nums) - 1
    while left <= right:
        if nums[left] == val:
            nums[left] = nums[right]
            right -= 1
        else:
            left += 1
    return left
```

**代码运行过程详细描述：**

以输入 `nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2` 为例，使用交换尾部双指针解法：

1.  初始化指针：`left = 0`, `right = 7`. `nums` = `[0, 1, 2, 2, 3, 0, 4, 2]`.
2.  进入 `while left <= right` 循环 (`0 <= 7`):
    *   `left = 0`: `nums[0]` 是 0. 0 != 2. 不是要移除的元素。 `left` 向右移动一位： `left = 1`.
        `nums` = `[0, 1, 2, 2, 3, 0, 4, 2]` (不变)
    *   `left = 1`: `nums[1]` 是 1. 1 != 2. 不是要移除的元素。 `left` 向右移动一位： `left = 2`.
        `nums` = `[0, 1, 2, 2, 3, 0, 4, 2]` (不变)
    *   `left = 2`: `nums[2]` 是 2. 2 == 2. 是要移除的元素。
        *   将 `nums[right]` (`nums[7]` 是 2) 复制到 `nums[left]` (`nums[2]`)： `nums[2] = nums[7]`. `nums` 变为 `[0, 1, **2**, 2, 3, 0, 4, **2**]`. (这里恰好相等，实际效果看不出来，但操作是复制).
        *   `right` 向左移动一位： `right = 6`.
        *   `left` 不动，需要再次检查 `nums[2]` (现在的值是 2)。
        `nums` = `[0, 1, **2**, 2, 3, 0, **4**, 2]`
    *   `left = 2`: `nums[2]` 是 2. 2 == 2. 是要移除的元素。
        *   将 `nums[right]` (`nums[6]` 是 4) 复制到 `nums[left]` (`nums[2]`)： `nums[2] = nums[6]`. `nums` 变为 `[0, 1, **4**, 2, 3, 0, 4, 2]`.
        *   `right` 向左移动一位： `right = 5`.
        *   `left` 不动，需要再次检查 `nums[2]` (现在的值是 4)。
        `nums` = `[0, 1, **4**, 2, 3, **0**, 4, 2]`
    *   `left = 2`: `nums[2]` 是 4. 4 != 2. 不是要移除的元素。 `left` 向右移动一位： `left = 3`.
        `nums` = `[0, 1, 4, 2, 3, 0, 4, 2]` (不变)
    *   `left = 3`: `nums[3]` 是 2. 2 == 2. 是要移除的元素。
        *   将 `nums[right]` (`nums[5]` 是 0) 复制到 `nums[left]` (`nums[3]`)： `nums[3] = nums[5]`. `nums` 变为 `[0, 1, 4, **0**, 3, 0, 4, 2]`.
        *   `right` 向左移动一位： `right = 4`.
        *   `left` 不动，需要再次检查 `nums[3]` (现在的值是 0)。
        `nums` = `[0, 1, 4, **0**, **3**, 0, 4, 2]`
    *   `left = 3`: `nums[3]` 是 0. 0 != 2. 不是要移除的元素。 `left` 向右移动一位： `left = 4`.
        `nums` = `[0, 1, 4, 0, 3, 0, 4, 2]` (不变)
    *   `left = 4`: `nums[4]` 是 3. 3 != 2. 不是要移除的元素。 `left` 向右移动一位： `left = 5`.
        `nums` = `[0, 1, 4, 0, 3, 0, 4, 2]` (不变)
    *   `left = 5`, `right = 4`. `left` (`5`) > `right` (`4`). 循环条件 `left <= right` 不满足，循环结束。

3.  循环结束后，`left` 的值为 5。
4.  返回 `left` 的值 5。

此时，`nums` 数组的前 5 个元素是 `[0, 1, 4, 0, 3]`，这 5 个元素都不等于 `val` (2)，它们的数量是 5，符合题意。