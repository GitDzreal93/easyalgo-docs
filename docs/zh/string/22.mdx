---
title: 22. 括号生成
description: 通过回溯算法生成所有有效的括号组合，确保左右括号正确匹配。
date: 2024-03-14
tag: [中等, 字符串, 回溯]
author: Easy Algo
premium: false
percentage: 30
---

## 题目

> leetcode 链接： [括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

**示例 1：**
```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**
```
输入：n = 1
输出：["()"]
```

**提示：**
```
1 <= n <= 8
```

## 题解

**题意简化：**

想象你是一位括号工厂的工人，现在老板给你一个数字 n，要求你生产出所有由 n 对括号组成的，并且左右括号能正确配对的组合。比如 n = 3，你就要生产出 "((()))", "(()())", "(())()", "()(())", "()()()" 这些产品。n 的范围不大，最小是 1，最大是 8。

**边界值与测试用例：**

*   **边界值：**
    *   n = 1, 输出 ["()"]
    *   n = 8, 这是最大值，不用太担心溢出。
*   **测试用例：**
    *   输入：n = 2
        输出：["(())", "()()"]
    *   输入：n = 3
        输出：["((()))", "(()())", "(())()", "()(())", "()()()"]

**解法分析：**

| 解法       | 优点                                                                                                                               | 缺点                                                                                                                                                                                                                            | 时间复杂度  | 空间复杂度  |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- | --------- |
| 暴力枚举     | 容易想到                                                                                                                             | 需要检验每一个生成的字符串是否有效，效率低                                                                                                                                                                                             | O(2<sup>2n</sup> * n) | O(2<sup>2n</sup> * n) |
| 回溯法     | 只生成有效的括号组合，避免了无效的搜索，效率较高                                                                                                                   | 相对暴力枚举，理解起来稍复杂                                                                                                                                                                                                | O(4<sup>n</sup> / √n) | O(4<sup>n</sup> / √n) |
| 动态规划   | 也可以解决，但是对于生成所有可能的组合，回溯法更直接。                                                                                                                               | 状态转移方程可能较为复杂                                                                                                                                                                                                 | O(4<sup>n</sup> / √n) | O(4<sup>n</sup> / √n) |

*   **复杂度评估方法：**
    *   时间复杂度：主要考虑生成所有可能括号组合的数量级。合法的括号组合数量是卡特兰数，其数量级为 O(4<sup>n</sup> / √n)。
    *   空间复杂度：存储所有合法的括号组合，因此空间复杂度与合法组合的数量级相同。

**推荐解法：**

我推荐使用**回溯法**。它只生成有效的括号组合，避免了无效的搜索，并且代码结构清晰，易于理解和记忆，非常适合面试。

**Python 代码实现：**

**版本一：包含详细注释**

```python
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        """
        生成所有有效的括号组合

        Args:
            n: 括号的对数

        Returns:
            所有有效括号组合的列表
        """
        result = []  # 存储结果的列表

        def backtrack(s, left, right):
            """
            回溯函数，用于生成括号组合

            Args:
                s: 当前的括号字符串
                left: 剩余可用的左括号数量
                right: 剩余可用的右括号数量
            """
            # 终止条件：当左右括号都用完时，将当前字符串添加到结果中
            if left == 0 and right == 0:
                result.append(s)
                return

            # 如果还有剩余的左括号，则可以添加左括号
            if left > 0:
                backtrack(s + "(", left - 1, right)

            # 如果右括号的数量多于左括号，则可以添加右括号
            if right > left:
                backtrack(s + ")", left, right - 1)

        # 从空字符串开始回溯
        backtrack("", n, n)
        return result
```

**版本二：去除所有注释**

```python
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        result = []

        def backtrack(s, left, right):
            if left == 0 and right == 0:
                result.append(s)
                return

            if left > 0:
                backtrack(s + "(", left - 1, right)

            if right > left:
                backtrack(s + ")", left, right - 1)

        backtrack("", n, n)
        return result
```

**代码运行过程详细描述：**

以 n = 2 为例，代码的执行流程如下：

1.  **初始化：** `result = []`, `backtrack("", 2, 2)`
2.  **第一次 backtrack：** `s = ""`, `left = 2`, `right = 2`
    *   添加左括号：`backtrack("(", 1, 2)`
3.  **第二次 backtrack：** `s = "("`, `left = 1`, `right = 2`
    *   添加左括号：`backtrack("((", 0, 2)`
4.  **第三次 backtrack：** `s = "(("`, `left = 0`, `right = 2`
    *   添加右括号：`backtrack("(()", 0, 1)`
5.  **第四次 backtrack：** `s = "(()"`, `left = 0`, `right = 1`
    *   添加右括号：`backtrack("(())", 0, 0)`
6.  **第五次 backtrack：** `s = "(())"`, `left = 0`, `right = 0`
    *   满足终止条件，`result.append("(())")`，函数返回。
7.  **回到第三次 backtrack：** 尝试添加右括号，`backtrack("()", 1, 1)`
8.  **第四次 backtrack：** `s = "()"`, `left = 1`, `right = 1`
    *   添加左括号：`backtrack("()(", 0, 1)`
9.  **第五次 backtrack：** `s = "()("`, `left = 0`, `right = 1`
    *   添加右括号：`backtrack("()()", 0, 0)`
10. **第六次 backtrack：** `s = "()()"`, `left = 0`, `right = 0`
    *   满足终止条件，`result.append("()()")`，函数返回。
11. **最终结果：** `result = ["(())", "()()"]`

希望这个解答对你有帮助！