---
title: 14. 最长公共前缀
description: 查找字符串数组中的最长公共前缀，若不存在返回空字符串。
date: 2024-03-14
tag: ["简单", "字符串"]
author: Easy Algo
premium: false
percentage: 30
---

## 题目

> leetcode 链接： [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。


**示例 1：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**
```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```
 

**提示：**
```
1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] 仅由小写英文字母组成
```

## 题解

**题意简化：**

想象你有一堆单词，比如 "flower", "flow", "flight"。你需要找出这些单词从头开始，共同拥有的最长部分。在这个例子中，共同拥有的最长前缀是 "fl"。如果这些单词没有任何共同的前缀，就像 "dog", "racecar", "car"，那么结果就是 ""。

**边界值与测试用例：**

*   **空数组：** `strs = []`， 结果：`""`
*   **单个字符串：** `strs = ["flower"]`，结果：`"flower"`
*   **无公共前缀：** `strs = ["dog", "racecar", "car"]`，结果：`""`
*   **完全相同：** `strs = ["flower", "flower", "flower"]`，结果：`"flower"`
*   **部分公共前缀：** `strs = ["flower", "flow", "flight"]`，结果：`"fl"`
*   **一个字符串是另一个的前缀：** `strs = ["flower", "flow"]`，结果：`"flow"`

**解法分析：**

| 解法           | 优点                                                                 | 缺点                                                                 | 时间复杂度 | 空间复杂度 |
| -------------- | -------------------------------------------------------------------- | -------------------------------------------------------------------- | -------- | -------- |
| 暴力法         | 简单直接，容易理解。                                                              | 效率较低，需要多次比较。                                                             | O(S)     | O(1)     |
| 水平扫描       | 比较次数相对较少。                                                              | 代码稍复杂。                                                               | O(S)     | O(1)     |
| 二分查找       | 在某些情况下效率较高。                                                              | 实现相对复杂。                                                               | O(S log n) | O(1)     |
| **垂直扫描**   | **代码简洁，效率较高，易于理解。**                                                        | **无明显缺点。**                                                               | **O(S)** | **O(1)** |
| 分治算法       | 可以并行处理，适用于大规模数据。                                                            | 实现复杂，开销较大。                                                               | O(S)     | O(m log n)     |

其中 S 是所有字符串中字符的总数，n 是字符串的数量，m 是字符串数组中最短的字符串的长度。

**复杂度评估方法：**

*   **时间复杂度：** 算法执行所需的时间，通常用大 O 符号表示。
*   **空间复杂度：** 算法执行所需的额外空间，同样用大 O 符号表示。

**推荐解法：**

我推荐**垂直扫描**方法，因为它在效率、代码简洁性和可理解性之间取得了很好的平衡，非常适合面试。

**Python 代码实现：**

```python
# 版本一：包含详细注释
def longestCommonPrefix(strs):
    """
    查找字符串数组中的最长公共前缀。

    Args:
        strs: 字符串数组。

    Returns:
        最长公共前缀，如果不存在则返回 ""。
    """
    if not strs:  # 如果数组为空，则没有公共前缀
        return ""

    for i in range(len(strs[0])):  # 遍历第一个字符串的每个字符
        char = strs[0][i]  # 当前要比较的字符
        for j in range(1, len(strs)):  # 遍历剩余的字符串
            if i >= len(strs[j]) or strs[j][i] != char:  # 如果当前字符串太短或者字符不匹配
                return strs[0][:i]  # 返回到目前为止的最长公共前缀

    return strs[0]  # 如果第一个字符串是所有字符串的前缀，则返回第一个字符串

# 版本二：去除所有注释
def longestCommonPrefix_简洁版(strs):
    if not strs:
        return ""

    for i in range(len(strs[0])):
        char = strs[0][i]
        for j in range(1, len(strs)):
            if i >= len(strs[j]) or strs[j][i] != char:
                return strs[0][:i]

    return strs[0]
```

**代码运行过程详细描述：**

以 `strs = ["flower", "flow", "flight"]` 为例：

1.  **初始化：** 函数首先检查字符串数组是否为空。
2.  **外层循环：** 遍历 "flower" 的每个字符。
    *   `i = 0`，`char = 'f'`
    *   **内层循环：** 遍历 "flow" 和 "flight"，检查它们的第一个字符是否也是 'f'。 结果是，它们都是。
    *   `i = 1`，`char = 'l'`
    *   **内层循环：** 遍历 "flow" 和 "flight"，检查它们的第二个字符是否也是 'l'。 结果是，它们都是。
    *   `i = 2`，`char = 'o'`
    *   **内层循环：** 当 `j = 1` 时，`strs[j] = "flow"`，`i = 2`，`char = 'o'`。`strs[1][2]` 是 'w'，不等于 'o'。
    *   函数返回 `strs[0][:2]`，也就是 "fl"。

希望这个解释对你有帮助！