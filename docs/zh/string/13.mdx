---
title: 13. 罗马数字转整数
description: 将罗马数字转换为整数，需处理特殊组合如IV（4）和IX（9）。遍历字符串判断左右字符大小。
date: 2024-03-14
tag: ["简单", "字符串"]
author: Easy Algo
premium: false
percentage: 30
---

## 题目

> leetcode 链接： [罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

**示例 1:**

```
输入: s = "III"
输出: 3
```

**示例 2:**
```
输入: s = "IV"
输出: 4
```

**示例 3:**
```
输入: s = "IX"
输出: 9
```

**示例 4:**
```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**
```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

**提示：**
```
1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。
```

## 题解

**题意简化：**

想象一下，你正在玩一个古老的数字游戏。游戏里不用我们熟悉的阿拉伯数字（1, 2, 3...），而是用罗马数字（I, V, X, L, C, D, M）。每个罗马数字都代表一个数值。现在，游戏规则是给你一个罗马数字，你需要把它翻译成我们熟悉的阿拉伯数字。但是，有一个小小的陷阱：当小的数字在大的数字前面时，不是加，而是要减。比如 "IV" 不是 1+5=6，而是 5-1=4。

**边界值与测试用例：**

*   空字符串：""  (虽然题目说了字符串非空，但考虑完整性)
*   单个字符："I", "V", "X", "L", "C", "D", "M"
*   最大值："MMMCMXCIX" (3999)
*   最小值："I" (1)
*   特殊情况："IV", "IX", "XL", "XC", "CD", "CM"

测试用例：

| 输入 (s)    | 输出 (整数) |
| :---------- | :---------- |
| "III"       | 3           |
| "IV"        | 4           |
| "IX"        | 9           |
| "LVIII"     | 58          |
| "MCMXCIV"   | 1994        |
| "MCDLXXVI"  | 1476        |

**解法分析：**

| 解法           | 优点                                                                     | 缺点                                                                 | 时间复杂度 | 空间复杂度 |
| :------------- | :----------------------------------------------------------------------- | :------------------------------------------------------------------- | :------- | :------- |
| 暴力法         | 直观易懂                                                                 | 代码冗长，需要处理多种情况                                                     | O(n)     | O(1)     |
| 查表法         | 速度快，代码简洁                                                               | 需要额外的空间存储映射表                                                       | O(n)     | O(1)     |
| 优化查表法（推荐） | 结合查表法和判断大小规则，代码简洁，易于理解。                                                               |                                                                    | O(n)     | O(1)     |

复杂度评估方法：

*   时间复杂度：代码执行所需的时间与输入规模的关系。O(n) 表示需要遍历整个字符串一次。
*   空间复杂度：代码执行所需的额外空间与输入规模的关系。O(1) 表示只需要固定的额外空间。

**推荐解法：优化查表法**

这种方法既容易理解，又能在面试中快速实现。我们用一个字典（或者哈希表）来存储罗马数字和整数的对应关系。然后，从左到右遍历罗马数字字符串，如果当前字符代表的数值小于下一个字符，就减去当前值；否则，就加上当前值。

**Python代码实现：**

版本一（包含详细注释）：

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        """
        将罗马数字字符串转换为整数。

        Args:
            s: 罗马数字字符串。

        Returns:
            对应的整数。
        """

        # 1. 定义罗马数字和对应整数的映射关系
        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}

        # 2. 初始化结果
        result = 0
        
        # 3. 遍历罗马数字字符串
        for i in range(len(s)):
            # 4. 获取当前字符代表的数值
            current_value = roman_map[s[i]]
            
            # 5. 判断当前字符是否小于下一个字符
            if i + 1 < len(s) and current_value < roman_map[s[i + 1]]:
                # 6. 如果小于，则减去当前值
                result -= current_value
            else:
                # 7. 否则，加上当前值
                result += current_value
        
        # 8. 返回结果
        return result
```

版本二（去除注释）：

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        result = 0
        for i in range(len(s)):
            current_value = roman_map[s[i]]
            if i + 1 < len(s) and current_value < roman_map[s[i + 1]]:
                result -= current_value
            else:
                result += current_value
        return result
```

**代码运行过程详细描述：**

以输入 "MCMXCIV" 为例：

1.  初始化 `result = 0`。
2.  循环遍历字符串 "MCMXCIV"：

    *   `i = 0`, `s[i] = 'M'`, `current_value = 1000`。因为 'M' 不是最后一个字符，且 `roman_map['M'] >= roman_map['C']`，所以 `result = 0 + 1000 = 1000`。
    *   `i = 1`, `s[i] = 'C'`, `current_value = 100`。因为 'C' 不是最后一个字符，且 `roman_map['C'] < roman_map['M']`，所以 `result = 1000 - 100 = 900`。
    *   `i = 2`, `s[i] = 'M'`, `current_value = 1000`。因为 'M' 不是最后一个字符，且 `roman_map['M'] >= roman_map['X']`，所以 `result = 900 + 1000 = 1900`。
    *   `i = 3`, `s[i] = 'X'`, `current_value = 10`。因为 'X' 不是最后一个字符，且 `roman_map['X'] < roman_map['C']`，所以 `result = 1900 - 10 = 1890`。
    *   `i = 4`, `s[i] = 'C'`, `current_value = 100`。因为 'C' 不是最后一个字符，且 `roman_map['C'] >= roman_map['I']`，所以 `result = 1890 + 100 = 1990`
    *   `i = 5`, `s[i] = 'I'`, `current_value = 1`。因为 'I' 不是最后一个字符，且 `roman_map['I'] < roman_map['V']`，所以 `result = 1990 - 1 = 1989`。
    *   `i = 6`, `s[i] = 'V'`, `current_value = 5`。因为 'V' 是最后一个字符，所以 `result = 1989 + 5 = 1994`。
3.  循环结束，返回 `result = 1994`。

希望这个解释能够帮助你理解这道题！