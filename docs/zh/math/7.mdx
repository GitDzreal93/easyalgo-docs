---
title: 7. 整数反转
description: 反转给定整数，若结果超出32位有符号整数范围则返回0。
date: 2024-03-14
tag: ["中等", "数学"]
author: Easy Algo
premium: false
percentage: 30
---

## 题目

> leetcode 链接：[整数反转](https://leetcode.cn/problems/reverse-integer/)

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2³¹,  2³¹ − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

**示例 3：**

```
输入：x = 120
输出：21
```

**示例 4：**

```
输入：x = 0
输出：0
```

**提示：**

```
-2³¹ <= x <= 2³¹ - 1
```


## 题解

**题意简化：**

想象你有一个数字，比如 123，你需要把这个数字倒过来变成 321。但是，如果倒过来的数字太大了，超过了我们能表示的范围（-2147483648 到 2147483647），就返回 0。如果原数字是负数，倒过来后也要是负数。

**边界值与测试用例：**

*   **正数：**
    *   `x = 123,  输出：321`
    *   `x = 120,  输出：21`
    *   `x = 1534236469, 输出：0 (超出范围)`
*   **负数：**
    *   `x = -123, 输出：-321`
    *   `x = -120, 输出：-21`
    *   `x = -1563847412, 输出：0 (超出范围)`
*   **零：**
    *   `x = 0,   输出：0`
*   **边界值：**
    *   `x = 2147483647, 输出：0 (超出范围)`
    *   `x = -2147483648, 输出：0 (超出范围)`

**解法分析：**

| 解法             | 优点                               | 缺点                               | 时间复杂度 | 空间复杂度 |
| ---------------- | ---------------------------------- | ---------------------------------- | -------- | -------- |
| 字符串转换         | 直观易懂                           | 涉及字符串操作，效率较低             | O(n)     | O(n)     |
| 数学计算（取余/整除） | 无需额外空间，效率较高                 | 需要考虑溢出问题                     | O(log n) | O(1)     |

*   **复杂度评估方法：**
    *   时间复杂度：主要看循环次数，与输入数字的位数有关，因此字符串转换是O(n)，数学计算是O(log n)。
    *   空间复杂度：主要看是否使用了额外空间，字符串转换需要额外空间存储字符串，数学计算只需要常数级别的变量。

**推荐解法：** 数学计算（取余/整除）

*   优点：性能更好，空间复杂度更低，更符合算法题的要求。
*   原因：更考察基本的数学运算和边界条件的处理。

**Python 代码实现：**

**版本一：包含详细注释**

```python
class Solution:
    def reverse(self, x: int) -> int:
        """
        反转整数
        """
        INT_MAX = 2**31 - 1  # 32位有符号整数的最大值
        INT_MIN = -2**31     # 32位有符号整数的最小值

        sign = -1 if x < 0 else 1  # 记录原始数字的符号
        x = abs(x)  # 将数字转换为正数进行处理

        reversed_num = 0
        while x > 0:
            digit = x % 10  # 取出最后一位数字
            x //= 10       # 去掉最后一位数字

            # 检查是否溢出
            if reversed_num > INT_MAX // 10 or (reversed_num == INT_MAX // 10 and digit > 7):
                return 0  # 正溢出
            if reversed_num < INT_MIN // 10 or (reversed_num == INT_MIN // 10 and digit < -8):
                return 0  # 负溢出

            reversed_num = reversed_num * 10 + digit  # 将当前位加到反转后的数字中

        return sign * reversed_num  # 恢复原始符号
```

**版本二：去除所有注释**

```python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MAX = 2**31 - 1
        INT_MIN = -2**31

        sign = -1 if x < 0 else 1
        x = abs(x)

        reversed_num = 0
        while x > 0:
            digit = x % 10
            x //= 10

            if reversed_num > INT_MAX // 10 or (reversed_num == INT_MAX // 10 and digit > 7):
                return 0
            if reversed_num < INT_MIN // 10 or (reversed_num == INT_MIN // 10 and digit < -8):
                return 0

            reversed_num = reversed_num * 10 + digit

        return sign * reversed_num
```

**代码运行过程：**

以输入 `x = 123` 为例：

1.  `sign = 1` (因为 x 是正数)
2.  `x = 123` (取绝对值，保持不变)
3.  `reversed_num = 0`
4.  **循环 1：**
    *   `digit = 123 % 10 = 3`
    *   `x = 123 // 10 = 12`
    *   `reversed_num = 0 * 10 + 3 = 3`
5.  **循环 2：**
    *   `digit = 12 % 10 = 2`
    *   `x = 12 // 10 = 1`
    *   `reversed_num = 3 * 10 + 2 = 32`
6.  **循环 3：**
    *   `digit = 1 % 10 = 1`
    *   `x = 1 // 10 = 0`
    *   `reversed_num = 32 * 10 + 1 = 321`
7.  循环结束，返回 `sign * reversed_num = 1 * 321 = 321`

如果输入 `x = -123`，过程类似，只是最后返回 `-321`。  代码中还包含了溢出检查，以确保结果在32位有符号整数的范围内。