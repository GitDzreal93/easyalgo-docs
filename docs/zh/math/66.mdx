---
title: 66. 加一
description: 在表示非负整数的数组上实现加一操作，处理进位和数组长度变化。
date: 2024-03-15
tag: ["简单", "数组", "数学"]
author: Easy Algo-臻叔
premium: false
percentage: 50
---

## 题目

> leetcode 链接： [加一](https://leetcode.cn/problems/plus-one/)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1**：

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2**：
```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3**：
```
输入：digits = [9]
输出：[1,0]
解释：输入数组表示数字 9。
加 1 得到了 9 + 1 = 10。
因此，结果应该是 [1,0]。
```

**提示**：
```
1 <= digits.length <= 100
0 <= digits[i] <= 9
```

## 题解

**题意简化：**

想象你有一个很大的数字，但是它不是直接写出来的，而是写在了一排卡片上，每张卡片一个数字，从左到右是高位到低位（比如 123 就是三张卡片 [1], [2], [3]）。现在，你需要给这个数加 1。就像我们平时手写加法一样，从最右边的卡片（个位）开始加 1，如果加完是 10，就把这张卡片变成 0，然后向左边更高位的那张卡片“进一位”。如果左边那张卡片也加出了 10，就继续进位，直到没有进位或者进到了最左边。如果最左边也进位了（比如卡片是 [9] 加 1 变成 10），那么你需要在最左边新加一张卡片写 1，原来的最左边卡片变成 0 ([1, 0])。最后把新的卡片排好返回。

**边界值与测试用例：**

*   **边界值：**
    *   数组只有一个元素 (`digits = [0]` 或 `[9]`)。
    *   数组所有元素都是 9 (`digits = [9, 9, 9]`)。
    *   加 1 后没有进位 (`digits = [1, 2, 3]`)。
    *   加 1 后有进位，但进位在中间就停止了 (`digits = [1, 9, 9]`)。

*   **测试用例：**

    | 输入 (digits)        | 预期输出      | 说明                     |
    | :------------------- | :------------ | :----------------------- |
    | `[1, 2, 3]`          | `[1, 2, 4]`   | 标准示例，无进位         |
    | `[4, 3, 2, 1]`       | `[4, 3, 2, 2]`| 标准示例，无进位         |
    | `[9]`                | `[1, 0]`      | 标准示例，需要扩展数组   |
    | `[0]`                | `[1]`         | 单个数字 0               |
    | `[1, 9, 9]`          | `[2, 0, 0]`   | 中间有进位               |
    | `[9, 9, 9]`          | `[1, 0, 0, 0]`| 所有数字都是 9，需要扩展 |

**解法分析：**

这个问题是模拟手写加法。由于数字是以数组形式存储，并且是从最高位到最低位排列，我们可以从数组的末尾（最低位）开始处理。

| 解法                     | 优点                 | 缺点                 | 时间复杂度 | 空间复杂度 |
| :----------------------- | :------------------- | :------------------- | :--------- | :--------- |
| 字符串转换 + 整数加法    | 简单易懂（Python） | 未模拟手写加法；需额外空间；跨语言有溢出风险 | O(N)       | O(N)       |
| 数学模拟（从右往左遍历） | 模拟手写加法；高效；O(1) 额外空间（不考虑输出数组创建） | 需要处理进位逻辑     | O(N)       | O(1)       |

*   **复杂度评估方法：**
    *   时间复杂度：衡量算法执行所需的计算操作数量随输入数组长度 (N) 增长的速度。O(N) 表示算法的运行时间与数组长度成正比，因为我们最多需要遍历整个数组一次。
    *   空间复杂度：衡量算法运行时占用的额外内存空间（不包括输入和输出数组本身）随输入数组长度 (N) 增长的速度。O(1) 表示只使用了固定数量的几个变量，不随数组长度变化。数学模拟方法通常只需要一个或两个变量来处理进位，因此是 O(1) 额外空间。字符串转换方法需要额外的空间存储字符串和新的数字数组，空间复杂度是 O(N)。

*   **推荐解法：**

    数学模拟（从右往左遍历）。这个方法直接模拟了我们手写加法的过程，从个位开始处理进位，直到没有进位或者进位到最高位。这种方法只需要一次遍历，并且只需要常数额外空间，是解决这个问题的标准且高效的方法。

**Python 代码实现：**

*   **版本一：包含详细注释**

```python
from typing import List # 导入 List 用于类型提示

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        """
        给一个表示非负整数的数字数组加一。

        Args:
            digits: 表示非负整数的整数数组 (非空)。

        Returns:
            加一后的数字数组。
        """
        # 获取数组的长度
        n = len(digits)

        # 从数组的最后一位开始向前遍历 (从最低位到最高位)
        # range(start, stop, step)
        # 从 n-1 (最后一位的索引) 开始，到 -1 结束 (不包含 -1)，步长为 -1 (向前)
        for i in range(n - 1, -1, -1):
            # 将当前位的数字加一
            digits[i] += 1

            # 检查当前位加一后是否等于 10
            if digits[i] == 10:
                # 如果等于 10，说明产生了进位
                # 当前位需要变为 0
                digits[i] = 0
                # 循环会自动移动到前一位 (i-1) 去处理进位，所以这里不需要额外的进位变量
            else:
                # 如果当前位加一后不等于 10 (即 0-9)
                # 说明没有产生进位，或者进位在这里被“消化”了
                # 整个加一过程就完成了，可以直接返回修改后的数组
                return digits

        # 如果循环结束了，说明最高位也发生了进位 (例如输入是 [9, 9, 9])
        # 此时整个数组的数字都变成了 0
        # 原来的数字是 99...9，加一后变成了 100...0
        # 需要在数组的最前面插入一个 1 来表示这个新的最高位
        # Python 的 list.insert(index, value) 方法会在指定索引处插入元素
        digits.insert(0, 1)

        # 返回处理后的数组
        return digits

# # 测试用例 (用于验证代码，实际提交时一般不包含)
# sol = Solution()
#
# print(f"Input: [1, 2, 3], Output: {sol.plusOne([1, 2, 3])}")         # Expected: [1, 2, 4]
# print(f"Input: [4, 3, 2, 1], Output: {sol.plusOne([4, 3, 2, 1])}")     # Expected: [4, 3, 2, 2]
# print(f"Input: [9], Output: {sol.plusOne([9])}")                     # Expected: [1, 0]
# print(f"Input: [0], Output: {sol.plusOne([0])}")                     # Expected: [1]
# print(f"Input: [1, 9, 9], Output: {sol.plusOne([1, 9, 9])}")         # Expected: [2, 0, 0]
# print(f"Input: [9, 9, 9], Output: {sol.plusOne([9, 9, 9])}")         # Expected: [1, 0, 0, 0]
```

*   **版本二：去除所有注释**

```python
from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        for i in range(n - 1, -1, -1):
            digits[i] += 1
            if digits[i] == 10:
                digits[i] = 0
            else:
                return digits
        digits.insert(0, 1)
        return digits
```

**代码运行过程详细描述：**

以输入 `digits = [1, 9, 9]` 为例：

1.  获取数组长度 `n = 3`.
2.  进入 `for i in range(2, -1, -1)` 循环：
    *   `i = 2`: `digits[2]` 是 9. `digits[2] += 1` 变为 10.
        *   检查 `digits[2] == 10`. 是。
        *   `digits[2] = 0`. 数组变为 `[1, 9, 0]`.
        *   循环继续到下一轮 (i 减 1)。
    *   `i = 1`: `digits[1]` 是 9. `digits[1] += 1` 变为 10.
        *   检查 `digits[1] == 10`. 是。
        *   `digits[1] = 0`. 数组变为 `[1, 0, 0]`.
        *   循环继续到下一轮 (i 减 1)。
    *   `i = 0`: `digits[0]` 是 1. `digits[0] += 1` 变为 2.
        *   检查 `digits[0] == 10`. 否 (`2 != 10`).
        *   进入 `else` 分支，执行 `return digits`. 返回当前数组 `[2, 0, 0]`.

整个过程结束，输出 `[2, 0, 0]`。

以输入 `digits = [9, 9, 9]` 为例：

1.  获取数组长度 `n = 3`.
2.  进入 `for i in range(2, -1, -1)` 循环：
    *   `i = 2`: `digits[2]` 是 9. `digits[2] += 1` 变为 10. `digits[2] = 0`. 数组变为 `[9, 9, 0]`. 继续。
    *   `i = 1`: `digits[1]` 是 9. `digits[1] += 1` 变为 10. `digits[1] = 0`. 数组变为 `[9, 0, 0]`. 继续。
    *   `i = 0`: `digits[0]` 是 9. `digits[0] += 1` 变为 10. `digits[0] = 0`. 数组变为 `[0, 0, 0]`. 继续。
3.  循环结束 (i 变为 -1)。
4.  循环结束后，程序来到 `digits.insert(0, 1)`. 在索引 0 处插入 1. 数组变为 `[1, 0, 0, 0]`.
5.  返回处理后的数组 `[1, 0, 0, 0]`.

整个过程结束，输出 `[1, 0, 0, 0]`。